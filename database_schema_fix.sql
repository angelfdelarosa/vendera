-- VENDRA - UPDATED DATABASE SCHEMA TO MATCH APPLICATION CODE
-- This script updates the database to match the TypeScript types and application expectations

-- First, drop existing tables to recreate them with correct structure
DROP TABLE IF EXISTS public.messages CASCADE;
DROP TABLE IF EXISTS public.conversations CASCADE;
DROP TABLE IF EXISTS public.favorites CASCADE;
DROP TABLE IF EXISTS public.properties CASCADE;
DROP TABLE IF EXISTS public.ratings CASCADE;
DROP TABLE IF EXISTS public.profiles CASCADE;

-- 1. PROFILES TABLE (Updated to match UserProfile interface)
CREATE TABLE public.profiles (
  id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
  full_name TEXT,
  username TEXT UNIQUE,
  email TEXT,
  avatar_url TEXT,
  bio TEXT,
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  created_at TIMESTAMPTZ DEFAULT NOW(),
  subscription_status TEXT DEFAULT 'inactive' CHECK (subscription_status IN ('active', 'inactive')),
  is_profile_complete BOOLEAN DEFAULT FALSE
);

COMMENT ON TABLE public.profiles IS 'Profile data for each user.';
COMMENT ON COLUMN public.profiles.id IS 'References the internal Supabase auth user.';

-- 2. PROPERTIES TABLE (Updated to use UUID and match Property interface)
CREATE TABLE public.properties (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  realtor_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  title TEXT NOT NULL,
  description TEXT,
  price NUMERIC NOT NULL,
  currency TEXT DEFAULT 'USD' CHECK (currency IN ('USD', 'DOP')),
  location TEXT,
  address TEXT,
  type TEXT CHECK (type IN ('house', 'apartment', 'condo', 'villa', 'lot')),
  bedrooms INT,
  bathrooms INT,
  area NUMERIC,
  features TEXT[],
  images TEXT[],
  is_active BOOLEAN DEFAULT TRUE,
  created_at TIMESTAMPTZ DEFAULT NOW()
);

COMMENT ON TABLE public.properties IS 'Real estate property listings.';
COMMENT ON COLUMN public.properties.realtor_id IS 'The user who listed the property.';

-- Indexes for performance
CREATE INDEX idx_properties_location ON public.properties(location);
CREATE INDEX idx_properties_type ON public.properties(type);
CREATE INDEX idx_properties_price ON public.properties(price);
CREATE INDEX idx_properties_is_active ON public.properties(is_active);

-- 3. RATINGS TABLE (New table for user ratings)
CREATE TABLE public.ratings (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  rated_user_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  rater_user_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  rating INT NOT NULL CHECK (rating >= 1 AND rating <= 5),
  comment TEXT,
  UNIQUE(rated_user_id, rater_user_id)
);

COMMENT ON TABLE public.ratings IS 'User ratings and reviews.';

-- 4. CONVERSATIONS TABLE (Updated to match application expectations)
CREATE TABLE public.conversations (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  buyer_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  seller_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  last_message_sender_id UUID REFERENCES public.profiles(id),
  last_message_read BOOLEAN DEFAULT FALSE,
  UNIQUE(buyer_id, seller_id)
);

COMMENT ON TABLE public.conversations IS 'Chat conversations between buyers and sellers.';

-- 5. MESSAGES TABLE
CREATE TABLE public.messages (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  conversation_id UUID NOT NULL REFERENCES public.conversations(id) ON DELETE CASCADE,
  sender_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  content TEXT NOT NULL
);

COMMENT ON TABLE public.messages IS 'Individual messages within conversations.';

-- 6. FUNCTIONS AND TRIGGERS

-- 6.1. Handle new user creation
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER
LANGUAGE plpgsql
SECURITY DEFINER SET search_path = public
AS $$
BEGIN
  INSERT INTO public.profiles (id, full_name, avatar_url, email, username)
  VALUES (
    NEW.id,
    NEW.raw_user_meta_data->>'full_name',
    NEW.raw_user_meta_data->>'avatar_url',
    NEW.email,
    COALESCE(NEW.raw_user_meta_data->>'username', SPLIT_PART(NEW.email, '@', 1) || '_' || SUBSTRING(MD5(random()::text), 0, 5))
  );
  RETURN NEW;
END;
$$;

-- Drop existing trigger if it exists
DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users;

-- Create the trigger
CREATE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW EXECUTE PROCEDURE public.handle_new_user();

-- 6.2. Update conversation on new message
CREATE OR REPLACE FUNCTION public.update_conversation_on_new_message()
RETURNS TRIGGER
LANGUAGE plpgsql
SECURITY DEFINER SET search_path = public
AS $$
BEGIN
  UPDATE public.conversations
  SET
    last_message_sender_id = NEW.sender_id,
    last_message_read = FALSE
  WHERE id = NEW.conversation_id;
  RETURN NEW;
END;
$$;

-- Drop existing trigger if it exists
DROP TRIGGER IF EXISTS on_message_inserted_update_conversation ON public.messages;

-- Create the trigger
CREATE TRIGGER on_message_inserted_update_conversation
  AFTER INSERT ON public.messages
  FOR EACH ROW EXECUTE PROCEDURE public.update_conversation_on_new_message();

-- 7. ROW LEVEL SECURITY (RLS)

-- Enable RLS on all tables
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.properties ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.ratings ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.conversations ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.messages ENABLE ROW LEVEL SECURITY;

-- Drop existing policies to avoid conflicts
DROP POLICY IF EXISTS "Users can view all profiles." ON public.profiles;
DROP POLICY IF EXISTS "Users can insert their own profile." ON public.profiles;
DROP POLICY IF EXISTS "Users can update their own profile." ON public.profiles;

DROP POLICY IF EXISTS "Anyone can view properties." ON public.properties;
DROP POLICY IF EXISTS "Authenticated users can create properties." ON public.properties;
DROP POLICY IF EXISTS "Users can update their own properties." ON public.properties;
DROP POLICY IF EXISTS "Users can delete their own properties." ON public.properties;

-- Policies for profiles
CREATE POLICY "Public profiles are viewable by everyone." ON public.profiles FOR SELECT USING (true);
CREATE POLICY "Users can insert their own profile." ON public.profiles FOR INSERT WITH CHECK (auth.uid() = id);
CREATE POLICY "Users can update own profile." ON public.profiles FOR UPDATE USING (auth.uid() = id);

-- Policies for properties
CREATE POLICY "Properties are viewable by everyone." ON public.properties FOR SELECT USING (true);
CREATE POLICY "Authenticated users can create properties." ON public.properties FOR INSERT WITH CHECK (auth.uid() = realtor_id);
CREATE POLICY "Users can update their own properties." ON public.properties FOR UPDATE USING (auth.uid() = realtor_id);
CREATE POLICY "Users can delete their own properties." ON public.properties FOR DELETE USING (auth.uid() = realtor_id);

-- Policies for ratings
CREATE POLICY "Ratings are viewable by everyone." ON public.ratings FOR SELECT USING (true);
CREATE POLICY "Users can manage their own ratings." ON public.ratings FOR ALL
USING (auth.uid() = rater_user_id)
WITH CHECK (auth.uid() = rater_user_id AND rated_user_id <> rater_user_id);

-- Policies for conversations
CREATE POLICY "Users can manage their own conversations." ON public.conversations FOR ALL USING (auth.uid() = buyer_id OR auth.uid() = seller_id);

-- Policies for messages
CREATE POLICY "Users can view messages in their conversations." ON public.messages FOR SELECT USING (conversation_id IN (SELECT id FROM public.conversations WHERE auth.uid() = buyer_id OR auth.uid() = seller_id));
CREATE POLICY "Users can send messages in their conversations." ON public.messages FOR INSERT WITH CHECK (auth.uid() = sender_id AND conversation_id IN (SELECT id FROM public.conversations WHERE auth.uid() = buyer_id OR auth.uid() = seller_id));

-- Enable realtime for tables
ALTER PUBLICATION supabase_realtime ADD TABLE public.profiles, public.properties, public.conversations, public.messages, public.ratings;